#!/usr/bin/env bash

# imirror
#
# Author: Christopher Harrison <ch12@sanger.ac.uk>
# Copyright (c) 2018 Genome Research Ltd.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

set -uo pipefail

readonly BINARY="$(readlink -fn "$0")"
readonly PROGNAME="$(basename "${BINARY}")"

# Maximum number of concurrent iputs
export IPUT_LIMIT="${IPUT_LIMIT-10}"

# Maximum number of elements in job array
export ELEMENTS="${ELEMENTS-200}"

readonly -A ANSI=(
  [reset]="$(tput sgr0)"
  [red]="$(tput setaf 1)"
  [bold]="$(tput bold)"
)

stderr() {
  local message="$*"

  if [[ -t 2 ]]; then
    message="${ANSI[red]}${message}${ANSI[reset]}"
  fi

  >&2 echo "${message}"
}

usage() {
  local indent="$(printf "%*s" ${#PROGNAME})"
  local usage="Usage"

  if [[ -t 1 ]]; then
    usage="${ANSI[bold]}${usage}${ANSI[reset]}"
  fi

  cat <<-EOF
	${usage}  ${PROGNAME} [--find FIND_OPTIONS...]
	       ${indent} [--bsub BSUB_OPTIONS...]
	       ${indent} [--iput IPUT_OPTIONS...]
	       ${indent} SOURCE TARGET
	
	Mirror a directory on a POSIX filesystem into an iRODS collection,
	distributing the upload over an LSF cluster.
	
	  --find FIND_OPTIONS...  Optional arguments passed to find(1)
	  --bsub BSUB_OPTIONS...  Optional arguments passed to LSF submission
	  --iput IPUT_OPTIONS...  Optional arguments passed to iRODS upload
	  SOURCE                  POSIX directory to source
	  TARGET                  iRODS collection to target
	
	${usage}  ${PROGNAME} --progress [SOURCE]
	
	Report on the progress of a previous invocation.
	
	  --progress [SOURCE]     POSIX source directory
	
	The current working directory is used, if the SOURCE is not specified.
	EOF
}

strip_prefix() {
  # Strip prefix from string
  local prefix="$1"
  local string="$2"
  echo "${string#${prefix}}"
}

working() {
  # Output working path
  local source="$1"
  local work_dir="${source}/.imirror"

  shift
  while (( $# )); do
    work_dir="${work_dir}/$1"
    shift
  done

  echo "${work_dir}"
}

progress_report() {
  # Output progress report for given source
  local source="$1"

  # TODO
  false
}

__setup() {
  # Setup job
  local source="$1"

  local find="$(working "${source}" bin find)"
  local bsub="$(working "${source}" bin bsub)"

  strip_source() {
    # Strip the prefixed source directory
    # from the find output and requote
    local quoted_source="$(stat -c "%N" "${source}")"
    cut -c "${#quoted_source}-" | sed "s/^/'/"
  }

  extract_dirs() {
    # Strip the last component from the first
    # column of the find output and requote
    cut -f1 \
    | grep -Po "^'.*\/(?=[^\/]+'$)" \
    | sed "s#\$#'#"
  }

  # Generate manifests
  echo -n "Generating manifests... "
  local manifest="$(working "${source}" manifest)"

  # Welcome to your nightmares!...
  local -A total
  eval "total=($(
    "${find}" \
    | strip_source \
    | tee >(split -da4 -en "r/${ELEMENTS}" - "${manifest}/files.") \
          >(extract_dirs | sort | uniq > "${manifest}/dirs") \
    | awk 'BEGIN { FS = "\t"; OFS = " " }
                 { files++; size += $2 }
           END   { print "[files]=" files, "[size]=" size }'))"

  echo "Done!"

  if (( ! total[files] )); then
    stderr "No files found to upload!"
    false
  fi

  echo "Found ${total[files]} to upload, totalling ${total[size]} bytes"
  echo "${total[files]}" > "$(working "${source}" log files)"
  echo "${total[size]}" > "$(working "${source}" log size)"

  # TODO Mirror subcollections on iRODS

  # Submit distributed upload
  echo -n "Submitting distributed upload jobs... "

  local -i elements="${ELEMENTS}"
  if (( total[files] < ELEMENTS )); then elements=${total[files]}; fi

  local copy_log="$(working "${source}" log "copy.%I.log")"
  local job_spec="imirror${RANDOM}[1-${elements}]%${IPUT_LIMIT}"
  local job_id

  if ! job_id="$("${bsub}" -o "${copy_log}" -e "${copy_log}" \
                           -J "${job_spec}" \
                           "${BINARY}" __copy "${source}")"; then
    stderr "Could not submit upload jobs!"
    false
  fi

  echo "Done!"
  echo "Upload submitted as job ${job_id}, distributed over ${elements} elements"
  echo "See logs in $(working "${source}" log) or use --progress"
}

__copy() {
  # Copy job
  local source="$1"

  # TODO
  false
}

main() {
  local -i show_help=1
  local -i fail_parse=0

  trap '(( show_help )) && usage; exit $(( ! show_help || fail_parse ))' ERR

  (( $# ))  # Fail on zero arguments

  # Check the first argument to determine the mode
  case "$1" in
    "__setup" | "__copy")
      # Internally called methods
      show_help=0

      local subcommand="$1"
      local source="$2"
      "${subcommand}" "${source}"
      ;;

    "--progress")
      # Show progress report
      show_help=0

      local source="$(readlink -fn "${2-.}")"
      progress_report "${source}"
      ;;

    *)
      # Normal invocation
      local -a find_args=()
      local -a bsub_args=()
      local -a iput_args=()

      if (( $# < 2 )); then
        stderr "Must provide a source and target!"
        fail_parse=1
        false
      fi

      local state
      while (( $# - 2 )); do
        case "$1" in
          "--find" | "--bsub" | "--iput")
            state="${1:2}"
            ;;

          *)
            if [[ -z "${state+x}" ]]; then
              stderr "Unknown option!"
              fail_parse=1
              false
            fi

            # Excuse me while I throw-up in my mouth
            eval "${state}_args+=(\"$1\")"
            ;;
        esac

        shift
      done

      # Remaining arguments are the source and target, respectively
      show_help=0
      local source="$(readlink -fn "$1")"
      local target="$2"

      if ! [[ -d "${source}" ]]; then
        stderr "Source directory does not exist!"
        false
      fi

      if [[ -d "$(working "${source}")" ]]; then
        stderr "imirror already run on source, showing progress report..."
        main --progress "${source}"
        exit
      fi

      if ! ils "${target}" >/dev/null 2>&1; then
        stderr "Target collection does not exist or cannot be accessed!"
        false
      fi

      # Initialise state
      umask 0077
      mkdir -p "$(working "${source}")/"{bin,manifest,log}

      initialise_script() {
        # Extract script from comments and apply templating
        # FIXME? Potential code injection vector; I think %q is safe
        local script="$1"
        local arguments=""
        local binary="$(working "${source}" bin "${script}")"

        shift
        if (( $# )); then
          arguments="$(printf '"%q" ' "$@")"
        fi

        grep -F "#@${script}" "${BINARY}" \
        | cut -f2- \
        | sed "s#{{SOURCE}}#${source}#g;s#{{TARGET}}#${target}#g;s#{{ARGS}}#${arguments}#g" \
        > "${binary}"

        chmod +x "${binary}"
      }

      initialise_script find "${find_args[@]+"${find_args[@]}"}"
      initialise_script bsub "${bsub_args[@]+"${bsub_args[@]}"}"
      initialise_script iput "${iput_args[@]+"${iput_args[@]}"}"

      local bsub="$(working "${source}" bin bsub)"
      local setup_log="$(working "${source}" log setup.log)"
      local job_id

      if ! job_id="$("${bsub}" -o "${setup_log}" -e "${setup_log}" \
                               "${BINARY}" __setup "${source}")"; then
        stderr "Could not submit setup job!"
        false
      fi

      echo "Mirroring ${source} to ${target}"
      echo "Setup submitted as job ${job_id}"
      echo "See logs in $(working "${source}" log) or use --progress"
      ;;
  esac
}

main "$@"

# find wrapper script
#@find	#!/usr/bin/env bash
#@find	set -e
#@find	declare TAB=$'\t'
#@find	find "{{SOURCE}}" \
#@find	     -mindepth 1 \
#@find	     \( -path "{{SOURCE}}/.imirror" -prune \) \
#@find	     -o \( -type f {{ARGS}} -exec stat -c "%N${TAB}%s" {} \; \)

# bsub wrapper script
#@bsub	#!/usr/bin/env bash
#@bsub	set -eo pipefail
#@bsub	bsub {{ARGS}} "$@" | grep -Po '(?<=Job <)\d+(?=>)'

# iput wrapper script
#@iput	#!/usr/bin/env bash
#@iput	set -eu
#@iput	declare RESTART_INFO="$(mktemp -d)"
#@iput	trap 'rm -rf "${RESTART_INFO}"' EXIT
#@iput	iput -fKT --wlock --retries 3 \
#@iput	     -X "${RESTART_INFO}/restart" \
#@iput	     --lfrestart "${RESTART_INFO}/lfrestart" \
#@iput	     {{ARGS}} \
#@iput	     "{{SOURCE}}/$1" "{{TARGET}}/$2"

## main() {
##   local mode="$1"
## 
##   case "${mode}" in
##     "__setup")
##       local source_dir="$2"
##       local dest_coll="$3"
## 
##       get_manifest() {
##         # Find files of a given type in the source directory, excluding
##         # the .imirror directory we created for keeping state
##         # FIXME This will break horribly for files with \n in their names
##         local type="$1"
##         find "${source_dir}" \
##              -mindepth 1 \
##              -path "${source_dir}/.imirror" -prune \
##              -o -type "${type}" -print
##       }
## 
##       # Generate manifest
##       echo "Generating manifest..."
##       local manifest_dir="${source_dir}/.imirror/manifest"
##       mkdir -p "${manifest_dir}"
##       get_manifest d > "${manifest_dir}/dirs"
##       get_manifest f | split -da4 -n "r/${ELEMENTS}" - "${manifest_dir}/files."
## 
##       # Create subcollections
##       echo "Mirroring directory structure on iRODS..."
##       local subdir
##       local subcoll
##       while IFS= read -r subdir; do
##         subcoll="${dest_coll}/$(strip_prefix "${source_dir}/" "${subdir}")"
##         imkdir -p "${subcoll}"
##       done < "${manifest_dir}/dirs"
## 
##       echo "Submitting distributed copy jobs..."
##       local log_dir="${source_dir}/.imirror/logs"
##       bsub -q normal \
##            -G hgi \
##            -M 1000 \
##            -R "select[mem>1000] rusage[mem=1000]" \
##            -J "imirror${RANDOM}[1-${ELEMENTS}]%${IPUT_LIMIT}" \
##            -o "${log_dir}/copy.%I.log" -e "${log_dir}/copy.%I.log" \
##            "${BINARY}" __copy "${source_dir}" "${dest_coll}"
##       ;;
## 
##     "__copy")
##       local source_dir="$2"
##       local dest_coll="$3"
## 
##       local -i manifest_id="$(( LSB_JOBINDEX - 1 ))"
##       local manifest="$(printf "${source_dir}/.imirror/manifest/files.%04d" "${manifest_id}")"
## 
##       echo "Beginning file copy..."
##       local source_file
##       local dest_file
##       local restart_info
##       while IFS= read -r source_file; do
##         restart_info="$(mktemp -d)"
##         dest_file="${dest_coll}/$(strip_prefix "${source_dir}/" "${source_file}")"
##         echo "Uploading ${source_file} to ${dest_file}"
##         iput -fKT --wlock --retries 3 \
##              -X "${restart_info}/restart" \
##              --lfrestart "${restart_info}/lfrestart" \
##              "${source_file}" "${dest_file}"
##         rm -rf "${restart_info}"
##       done < "${manifest}"
## 
##       echo "Done"
##       ;;
